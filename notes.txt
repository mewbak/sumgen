If arbitrary are able to specify sumdefs, we have to group sumdefs by similar *types.Interface's. Then we would have to look up that type in each scope, instead of checking that it is attached to a type definition.

For now, the InterfaceType decl that the comment is associated with is the one it is attached to.

-mirror flag that removes other methods of that type

more errors when type is missing

multiple entry points for go generate

work on arbitrary packages passed as flags.
however, scoped to that package.

add tests!
1. Test that sum type definitions are parsed correctly.
2. Test that missing methods are computed properly
3. 

//go:generate sumgen -t A = B
-p specifies package name (is this even possible?)
-t specifies the type name
-o specifies the output file name

//go:generate sumgen -p pkg1 pkg2
//go:generate sumgen -t A = B
//go:generate sumgen
//go:generate

type generator struct {
	pkg *types.Package
	info *types.Info
	defs []SumDef
	methods []Func
}

test arbitrary whitespace in definitions
test multiple defs in one comment
test multiple functions/signatures in interface decl
test multiple interface decls
test unexported types


1. Parse Sum type definitions from comments. Get the InterfaceType it is attached to. If there is no InterfaceType attached, then skip this comment.
Go to all interface type definitions and scan adjacent comments for sumdef.
type SumDef struct {
	Type *types.Interface
	Rhs []string
}
end up with aggregate SumDef containing union of rhs's in []SumDef.
type Func struct {
	Recv string
	F *types.Func
}
2. For each SumDef.Type in []SumDef,
		For each RhsType in Rhs
			Funcs = append(Funcs, MissingMethods(RhsType, SumDef.Type)...)
3. For each Func in Funcs
		recvar = string(Recv[0])
		if len(Recv) == 1
			recvar += Recv
		recvar = ToLower(recvar)
		write the following to a buffer
		func ($recvar$ $Recv$) $Name()$ $Signature$ { panic("not implemented") }
