package main

import (
	"bytes"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"testing"
)

const header = "// Code generated by \"sumgen\"; DO NOT EDIT.\n\n\npackage test\n"

//TODO: test failure cases as well

var writeTests = []struct {
	in   []Func
	want string
}{
	{
		in:   []Func{{false, "a", "expr", "func()"}},
		want: "func (aa a) expr() { panic(\"default implementation\") }\n",
	},
	{
		in:   []Func{{false, "日", "expr", "func()"}},
		want: "func (日日 日) expr() { panic(\"default implementation\") }\n",
	},
	{
		in:   []Func{{false, "aa", "expr", "func()"}},
		want: "func (a aa) expr() { panic(\"default implementation\") }\n",
	},
	{
		in:   []Func{{false, "日本語", "expr", "func()"}},
		want: "func (日 日本語) expr() { panic(\"default implementation\") }\n",
	},
	{
		in: []Func{
			{false, "日本語", "A", "func()"},
			{false, "日", "A", "func()"},
			{false, "日本", "A", "func()"},
		},
		want: "func (日 日本語) A() { panic(\"default implementation\") }\n" +
			"func (日日 日) A() { panic(\"default implementation\") }\n" +
			"func (日 日本) A() { panic(\"default implementation\") }\n",
	},
	{
		in: []Func{
			{false, "日本語", "A", "func()"},
			{false, "日本語", "B", "func()"},
			{false, "日本語", "C", "func()"},
		},
		want: "func (日 日本語) A() { panic(\"default implementation\") }\n" +
			"func (日 日本語) B() { panic(\"default implementation\") }\n" +
			"func (日 日本語) C() { panic(\"default implementation\") }\n",
	},
	{
		in: []Func{
			{false, "日本語", "A", "func(a, b int) int"},
			{false, "日本語", "B", "func(a ...func(int))"},
			{false, "日本語", "C", "func(b ...interface{}) (a int)"},
		},
		want: "func (日 日本語) A(a, b int) int { panic(\"default implementation\") }\n" +
			"func (日 日本語) B(a ...func(int)) { panic(\"default implementation\") }\n" +
			"func (日 日本語) C(b ...interface{}) (a int) { panic(\"default implementation\") }\n",
	},
	{
		in: []Func{
			{true, "日本語", "A", "func(a, b int) *int"},
			{true, "日本語", "B", "func(a ...func(int))"},
			{true, "日本語", "C", "func(b ...interface{}) (a int)"},
		},
		want: "func (日 *日本語) A(a, b int) *int { panic(\"default implementation\") }\n" +
			"func (日 *日本語) B(a ...func(int)) { panic(\"default implementation\") }\n" +
			"func (日 *日本語) C(b ...interface{}) (a int) { panic(\"default implementation\") }\n",
	},
}

func TestWriteMethods(t *testing.T) {
	var buf bytes.Buffer
	for i, test := range writeTests {
		if err := writeHeader(&buf, "test"); err != nil {
			t.Fatal(err)
		}
		if err := writeMethods(&buf, test.in); err != nil {
			t.Fatal(err)
		}
		g := buf.String()
		w := header + test.want
		if g != w {
			t.Errorf("case %d, want: %q, got: %q", i, w, g)
		}
		buf.Reset()
	}
}

var testMissing = []struct {
	in   string
	want []Func
}{
	{
		in: `
//go:generate sumgen A = B
type A interface {
	a()
}

type B int
`,
		want: []Func{{false, "B", "a", "func()"}},
	},
	{
		in: `
//go:generate sumgen A = B | C
type A interface {
	a()
}

type B int

type C struct {
	int
}
`,
		want: []Func{
			{false, "B", "a", "func()"},
			{false, "C", "a", "func()"},
		},
	},
	{
		in: `
//go:generate sumgen A = *B | *C
type A interface {
	a()
}

type B int

type C struct {
	int
}
`,
		want: []Func{
			{true, "B", "a", "func()"},
			{true, "C", "a", "func()"},
		},
	},
	{
		in: `
//go:generate sumgen 
//  A 
//		=	B |
//C
type A interface {
	a()
}

type B int

type C struct {
	int
}
`,
		want: []Func{
			{false, "B", "a", "func()"},
			{false, "C", "a", "func()"},
		},
	},
	{
		in: `
//go:generate sumgen 
//  A 
//	    =	B |
//C
//go:generate sumgen A = C | 
//	d
type A interface {
	a()
}

type B int

type C struct {
	int
}

type d func(int)
`,
		want: []Func{
			{false, "B", "a", "func()"},
			{false, "C", "a", "func()"},
			{false, "d", "a", "func()"},
		},
	},
	{
		in: `
//go:generate sumgen A = B | C
//go:generate sumgen A = C | d
type A interface {
	a()
	b(int) int
}

type B int

type C struct {
	int
}

type d func(int)
`,
		want: []Func{
			{false, "B", "a", "func()"},
			{false, "B", "b", "func(int) int"},
			{false, "C", "a", "func()"},
			{false, "C", "b", "func(int) int"},
			{false, "d", "a", "func()"},
			{false, "d", "b", "func(int) int"},
		},
	},
	{
		in: `
//go:generate sumgen A = B | C
//go:generate sumgen A = C | d
type A interface {
	a()
	b(int) int
}

type B int

type C struct {
	int
}

type d func(int)

//go:generate sumgen E = B | d
type E interface {
	b(int) int
	varargs(v ...interface{})
}`,
		want: []Func{
			{false, "B", "a", "func()"},
			{false, "B", "b", "func(int) int"},
			{false, "C", "a", "func()"},
			{false, "C", "b", "func(int) int"},
			{false, "d", "a", "func()"},
			{false, "d", "b", "func(int) int"},
			{false, "B", "varargs", "func(v ...interface{})"},
			{false, "d", "varargs", "func(v ...interface{})"},
		},
	},
}

func TestMissingMethods(t *testing.T) {
	// create temporary directory for package
	dir, err := ioutil.TempDir("", "sumgen")
	if err != nil {
		t.Fatal(err)
	}
	fname := filepath.Join(dir, "test.go")
	defer os.RemoveAll(dir)
	for i, test := range testMissing {
		prog := []byte(header + test.in)
		if err := ioutil.WriteFile(fname, prog, 0755); err != nil {
			t.Fatal(err)
		}
		g := generator{imports: make(map[string]struct{})}
		if err := g.parseAndTypeCheck(dir); err != nil {
			t.Fatal(err)
		}
		if err := g.parseSumDefs(); err != nil {
			t.Fatal(err)
		}
		if err := g.genMissingMethods(); err != nil {
			t.Fatal(err)
		}
		if g.methods, err = validate(g.methods); err != nil {
			t.Fatal(err)
		}
		if !reflect.DeepEqual(g.methods, test.want) {
			t.Errorf("case %d want %v, got %v", i, test.want, g.methods)
		}
	}
}
